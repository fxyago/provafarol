{"ast":null,"code":"import \"core-js/modules/es.object.to-string.js\";\nimport \"core-js/modules/es.regexp.to-string.js\";\nimport \"core-js/modules/es.regexp.exec.js\";\nimport \"core-js/modules/es.string.replace.js\";\nimport \"core-js/modules/es.array.join.js\";\nimport \"core-js/modules/es.array.filter.js\";\nimport \"core-js/modules/es.array.map.js\";\nimport \"core-js/modules/es.string.trim.js\";\nimport \"core-js/modules/web.dom-collections.for-each.js\";\nimport \"core-js/modules/es.string.split.js\";\nimport \"core-js/modules/es.array.concat.js\";\nimport { RX_ENCODED_COMMA, RX_ENCODE_REVERSE, RX_PLUS, RX_QUERY_START } from '../constants/regex';\nimport { isTag } from './dom';\nimport { isArray, isNull, isPlainObject, isString, isUndefined } from './inspect';\nimport { keys } from './object';\nimport { toString } from './string';\nvar ANCHOR_TAG = 'a'; // Method to replace reserved chars\n\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n}; // Fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\n\n\nvar encode = function encode(str) {\n  return encodeURIComponent(toString(str)).replace(RX_ENCODE_REVERSE, encodeReserveReplacer).replace(RX_ENCODED_COMMA, ',');\n};\n\nvar decode = decodeURIComponent; // Stringifies an object of query parameters\n// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\n\nexport var stringifyQueryObj = function stringifyQueryObj(obj) {\n  if (!isPlainObject(obj)) {\n    return '';\n  }\n\n  var query = keys(obj).map(function (key) {\n    var value = obj[key];\n\n    if (isUndefined(value)) {\n      return '';\n    } else if (isNull(value)) {\n      return encode(key);\n    } else if (isArray(value)) {\n      return value.reduce(function (results, value2) {\n        if (isNull(value2)) {\n          results.push(encode(key));\n        } else if (!isUndefined(value2)) {\n          // Faster than string interpolation\n          results.push(encode(key) + '=' + encode(value2));\n        }\n\n        return results;\n      }, []).join('&');\n    } // Faster than string interpolation\n\n\n    return encode(key) + '=' + encode(value);\n  })\n  /* must check for length, as we only want to filter empty strings, not things that look falsey! */\n  .filter(function (x) {\n    return x.length > 0;\n  }).join('&');\n  return query ? \"?\".concat(query) : '';\n};\nexport var parseQuery = function parseQuery(query) {\n  var parsed = {};\n  query = toString(query).trim().replace(RX_QUERY_START, '');\n\n  if (!query) {\n    return parsed;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(RX_PLUS, ' ').split('=');\n    var key = decode(parts.shift());\n    var value = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (isUndefined(parsed[key])) {\n      parsed[key] = value;\n    } else if (isArray(parsed[key])) {\n      parsed[key].push(value);\n    } else {\n      parsed[key] = [parsed[key], value];\n    }\n  });\n  return parsed;\n};\nexport var isLink = function isLink(props) {\n  return !!(props.href || props.to);\n};\nexport var isRouterLink = function isRouterLink(tag) {\n  return !!(tag && !isTag(tag, 'a'));\n};\nexport var computeTag = function computeTag(_ref, thisOrParent) {\n  var to = _ref.to,\n      disabled = _ref.disabled,\n      routerComponentName = _ref.routerComponentName;\n  var hasRouter = !!thisOrParent.$router;\n\n  if (!hasRouter || hasRouter && (disabled || !to)) {\n    return ANCHOR_TAG;\n  } // TODO:\n  //   Check registered components for existence of user supplied router link component name\n  //   We would need to check PascalCase, kebab-case, and camelCase versions of name:\n  //   const name = routerComponentName\n  //   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]\n  //   exists = names.some(name => !!thisOrParent.$options.components[name])\n  //   And may want to cache the result for performance or we just let the render fail\n  //   if the component is not registered\n\n\n  return routerComponentName || (thisOrParent.$nuxt ? 'nuxt-link' : 'router-link');\n};\nexport var computeRel = function computeRel() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      target = _ref2.target,\n      rel = _ref2.rel;\n\n  return target === '_blank' && isNull(rel) ? 'noopener' : rel || null;\n};\nexport var computeHref = function computeHref() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      href = _ref3.href,\n      to = _ref3.to;\n\n  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;\n  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';\n  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/'; // Return `href` when explicitly provided\n\n  if (href) {\n    return href;\n  } // We've checked for `$router` in `computeTag()`, so `isRouterLink()` indicates a live router\n  // When deferring to Vue Router's `<router-link>`, don't use the `href` attribute at all\n  // We return `null`, and then remove `href` from the attributes passed to `<router-link>`\n\n\n  if (isRouterLink(tag)) {\n    return null;\n  } // Fallback to `to` prop (if `to` is a string)\n\n\n  if (isString(to)) {\n    return to || toFallback;\n  } // Fallback to `to.path' + `to.query` + `to.hash` prop (if `to` is an object)\n\n\n  if (isPlainObject(to) && (to.path || to.query || to.hash)) {\n    var path = toString(to.path);\n    var query = stringifyQueryObj(to.query);\n    var hash = toString(to.hash);\n    hash = !hash || hash.charAt(0) === '#' ? hash : \"#\".concat(hash);\n    return \"\".concat(path).concat(query).concat(hash) || toFallback;\n  } // If nothing is provided return the fallback\n\n\n  return fallback;\n};","map":{"version":3,"sources":["C:/Users/Yago/Documents/Eclipse/Yago/farolshopping/src/frontend/farolshopping/node_modules/bootstrap-vue/esm/utils/router.js"],"names":["RX_ENCODED_COMMA","RX_ENCODE_REVERSE","RX_PLUS","RX_QUERY_START","isTag","isArray","isNull","isPlainObject","isString","isUndefined","keys","toString","ANCHOR_TAG","encodeReserveReplacer","c","charCodeAt","encode","str","encodeURIComponent","replace","decode","decodeURIComponent","stringifyQueryObj","obj","query","map","key","value","reduce","results","value2","push","join","filter","x","length","concat","parseQuery","parsed","trim","split","forEach","param","parts","shift","isLink","props","href","to","isRouterLink","tag","computeTag","_ref","thisOrParent","disabled","routerComponentName","hasRouter","$router","$nuxt","computeRel","_ref2","arguments","undefined","target","rel","computeHref","_ref3","fallback","toFallback","path","hash","charAt"],"mappings":"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","sourcesContent":["import { RX_ENCODED_COMMA, RX_ENCODE_REVERSE, RX_PLUS, RX_QUERY_START } from '../constants/regex';\nimport { isTag } from './dom';\nimport { isArray, isNull, isPlainObject, isString, isUndefined } from './inspect';\nimport { keys } from './object';\nimport { toString } from './string';\nvar ANCHOR_TAG = 'a'; // Method to replace reserved chars\n\nvar encodeReserveReplacer = function encodeReserveReplacer(c) {\n  return '%' + c.charCodeAt(0).toString(16);\n}; // Fixed encodeURIComponent which is more conformant to RFC3986:\n// - escapes [!'()*]\n// - preserve commas\n\n\nvar encode = function encode(str) {\n  return encodeURIComponent(toString(str)).replace(RX_ENCODE_REVERSE, encodeReserveReplacer).replace(RX_ENCODED_COMMA, ',');\n};\n\nvar decode = decodeURIComponent; // Stringifies an object of query parameters\n// See: https://github.com/vuejs/vue-router/blob/dev/src/util/query.js\n\nexport var stringifyQueryObj = function stringifyQueryObj(obj) {\n  if (!isPlainObject(obj)) {\n    return '';\n  }\n\n  var query = keys(obj).map(function (key) {\n    var value = obj[key];\n\n    if (isUndefined(value)) {\n      return '';\n    } else if (isNull(value)) {\n      return encode(key);\n    } else if (isArray(value)) {\n      return value.reduce(function (results, value2) {\n        if (isNull(value2)) {\n          results.push(encode(key));\n        } else if (!isUndefined(value2)) {\n          // Faster than string interpolation\n          results.push(encode(key) + '=' + encode(value2));\n        }\n\n        return results;\n      }, []).join('&');\n    } // Faster than string interpolation\n\n\n    return encode(key) + '=' + encode(value);\n  })\n  /* must check for length, as we only want to filter empty strings, not things that look falsey! */\n  .filter(function (x) {\n    return x.length > 0;\n  }).join('&');\n  return query ? \"?\".concat(query) : '';\n};\nexport var parseQuery = function parseQuery(query) {\n  var parsed = {};\n  query = toString(query).trim().replace(RX_QUERY_START, '');\n\n  if (!query) {\n    return parsed;\n  }\n\n  query.split('&').forEach(function (param) {\n    var parts = param.replace(RX_PLUS, ' ').split('=');\n    var key = decode(parts.shift());\n    var value = parts.length > 0 ? decode(parts.join('=')) : null;\n\n    if (isUndefined(parsed[key])) {\n      parsed[key] = value;\n    } else if (isArray(parsed[key])) {\n      parsed[key].push(value);\n    } else {\n      parsed[key] = [parsed[key], value];\n    }\n  });\n  return parsed;\n};\nexport var isLink = function isLink(props) {\n  return !!(props.href || props.to);\n};\nexport var isRouterLink = function isRouterLink(tag) {\n  return !!(tag && !isTag(tag, 'a'));\n};\nexport var computeTag = function computeTag(_ref, thisOrParent) {\n  var to = _ref.to,\n      disabled = _ref.disabled,\n      routerComponentName = _ref.routerComponentName;\n  var hasRouter = !!thisOrParent.$router;\n\n  if (!hasRouter || hasRouter && (disabled || !to)) {\n    return ANCHOR_TAG;\n  } // TODO:\n  //   Check registered components for existence of user supplied router link component name\n  //   We would need to check PascalCase, kebab-case, and camelCase versions of name:\n  //   const name = routerComponentName\n  //   const names = [name, PascalCase(name), KebabCase(name), CamelCase(name)]\n  //   exists = names.some(name => !!thisOrParent.$options.components[name])\n  //   And may want to cache the result for performance or we just let the render fail\n  //   if the component is not registered\n\n\n  return routerComponentName || (thisOrParent.$nuxt ? 'nuxt-link' : 'router-link');\n};\nexport var computeRel = function computeRel() {\n  var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      target = _ref2.target,\n      rel = _ref2.rel;\n\n  return target === '_blank' && isNull(rel) ? 'noopener' : rel || null;\n};\nexport var computeHref = function computeHref() {\n  var _ref3 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n      href = _ref3.href,\n      to = _ref3.to;\n\n  var tag = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ANCHOR_TAG;\n  var fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '#';\n  var toFallback = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n\n  // Return `href` when explicitly provided\n  if (href) {\n    return href;\n  } // We've checked for `$router` in `computeTag()`, so `isRouterLink()` indicates a live router\n  // When deferring to Vue Router's `<router-link>`, don't use the `href` attribute at all\n  // We return `null`, and then remove `href` from the attributes passed to `<router-link>`\n\n\n  if (isRouterLink(tag)) {\n    return null;\n  } // Fallback to `to` prop (if `to` is a string)\n\n\n  if (isString(to)) {\n    return to || toFallback;\n  } // Fallback to `to.path' + `to.query` + `to.hash` prop (if `to` is an object)\n\n\n  if (isPlainObject(to) && (to.path || to.query || to.hash)) {\n    var path = toString(to.path);\n    var query = stringifyQueryObj(to.query);\n    var hash = toString(to.hash);\n    hash = !hash || hash.charAt(0) === '#' ? hash : \"#\".concat(hash);\n    return \"\".concat(path).concat(query).concat(hash) || toFallback;\n  } // If nothing is provided return the fallback\n\n\n  return fallback;\n};"]},"metadata":{},"sourceType":"module"}